import { Entity } from '../../../../domain';
import { prop } from '../../../define';
import { castPropertyToColumnName } from '../../utils/castPropertyToColumnName';
import { pickKeysFromObject } from '../../utils/pickKeysFromObject';
import { defineMappingTableInsertsForArrayProperty } from './defineMappingTableInsertsForArrayProperty';
import { castPropertyToInputVariableName } from './utils/castPropertyToInputVariableName';
import { castPropertyToTableColumnValueReference } from './utils/castPropertyToTableColumnValueReference';
import { castPropertyToWhereClauseConditional } from './utils/castPropertyToWhereClauseConditional';

export const defineFindOrCreateStaticEntityLogic = ({
  entity,
}: {
  entity: Entity;
}) => {
  // define whether the entity is unique on uuid alone
  const entityIsUniqueOnUuid =
    entity.unique.length === 1 && entity.unique[0] === 'uuid';

  // define the static property names
  const staticPropertyNames = Object.entries(entity.properties)
    .filter((entry) => !entry[1].updatable)
    .map((entry) => entry[0]);

  // define the column names and the column value references for the static properties
  const staticPropertyColumnNames = staticPropertyNames.map((name) =>
    castPropertyToColumnName({ name, definition: entity.properties[name]! }),
  );
  const staticPropertyColumnValueReferences = staticPropertyNames.map((name) =>
    castPropertyToTableColumnValueReference({
      name,
      definition: entity.properties[name]!,
    }),
  );

  // define the unique static property where clauses (for finding the entity by unique values)
  const uniqueStaticPropertyWhereClauseConditionals = (() => {
    // if the entity is unique on the uuid alone, that is the where clause conditional
    if (entityIsUniqueOnUuid) {
      return [
        castPropertyToWhereClauseConditional({
          name: 'uuid',
          definition: prop.UUID(),
          tableAlias: 's',
        }),
      ];
    }

    // otherwise, define the where clause conditionals as normal
    const uniqueStaticPropertyNames = staticPropertyNames.filter((name) =>
      entity.unique.includes(name),
    );
    return uniqueStaticPropertyNames.map((name) =>
      castPropertyToWhereClauseConditional({
        name,
        definition: entity.properties[name]!,
        tableAlias: 's',
      }),
    );
  })();

  // define the array properties, for which we'll need to insert into a mapping table
  const staticArrayProperties = pickKeysFromObject({
    object: entity.properties,
    keep: (property) => !!property.array && !property.updatable,
  });
  const mappingTableInserts = Object.entries(staticArrayProperties).map(
    ([name, definition]) =>
      defineMappingTableInsertsForArrayProperty({
        name,
        definition,
        entityName: entity.name,
      }),
  );

  // define whether the uuid should be autogenerated or passed in, based on unique keys of entity
  const uuidValueReference = entityIsUniqueOnUuid
    ? castPropertyToInputVariableName({ name: 'uuid' })
    : 'uuid_generate_v4()';

  // define the sql
  return `
-- find or create the static record
SELECT s.id INTO v_static_id -- try to find the id of the static record
FROM ${entity.name} AS s
WHERE 1=1
  ${uniqueStaticPropertyWhereClauseConditionals.join('\n  ')};
IF (v_static_id IS NULL) THEN -- if static record could not be already found, create the static record
  INSERT INTO ${entity.name} AS s
    (${['uuid', 'created_at', ...staticPropertyColumnNames].join(', ')})
    VALUES
    (${[
      uuidValueReference,
      'v_created_at',
      ...staticPropertyColumnValueReferences,
    ].join(', ')})
    RETURNING s.id INTO v_static_id; ${
      // ensure that no newlines are added if no mapping table inserts are needed
      mappingTableInserts.length
        ? ['', ...mappingTableInserts].join('\n\n  ')
        : ''
    }
END IF;
`.trim();
};
