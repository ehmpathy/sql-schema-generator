// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateEntityUpsert entity that references another entity by version should produce the same syntax as the SHOW CREATE FUNCTION query 1`] = `
"CREATE FUNCTION \`upsert_crash_report\`(
  in_location_id bigint(20),
  in_vehicle_version_id bigint(20)
) RETURNS bigint(20)
BEGIN
  -- declarations
  DECLARE v_static_id BIGINT;
  DECLARE v_created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6); -- define a common created_at timestamp to use

  -- find or create the static entity
  SET v_static_id = (
    SELECT id
    FROM crash_report
    WHERE 1=1
      AND (location_id = BINARY in_location_id)
      AND (vehicle_version_id = BINARY in_vehicle_version_id)
  );
  IF (v_static_id IS NULL) THEN -- if entity could not be found originally, create the static entity
    INSERT INTO crash_report
      (uuid, created_at, location_id, vehicle_version_id)
      VALUES
      (uuid(), v_created_at, in_location_id, in_vehicle_version_id);
    SET v_static_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- return the static entity id
  return v_static_id;
END"
`;

exports[`generateEntityUpsert entity with array properties should produce the same syntax as the SHOW CREATE FUNCTION query 1`] = `
"CREATE FUNCTION \`upsert_movie\`(
  in_name varchar(255),
  in_producer_ids varchar(16383),
  in_language_ids varchar(16383)
) RETURNS bigint(20)
BEGIN
  -- declarations
  DECLARE v_static_id BIGINT;
  DECLARE v_created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6); -- define a common created_at timestamp to use
  DECLARE v_matching_version_id BIGINT;
  DECLARE v_effective_at DATETIME(6) DEFAULT v_created_at; -- define the effective_at to equal created_at by default (i.e., effective _now_)
  DECLARE v_current_version_id_recorded_in_pointer_table BIGINT;
  DECLARE v_effective_at_of_current_version_recorded_in_pointer_table DATETIME(6);
  DECLARE v_delimited_string_access_index INT;
  DECLARE v_delimited_string_access_value VARCHAR(255);
  DECLARE v_can_still_find_values_in_delimited_string BOOLEAN;

  -- find or create the static entity
  SET v_static_id = (
    SELECT id
    FROM movie
    WHERE 1=1
      AND (name = BINARY in_name)
      AND (producer_ids_hash = BINARY SHA2(in_producer_ids, 256))
  );
  IF (v_static_id IS NULL) THEN -- if entity could not be found originally, create the static entity
    INSERT INTO movie
      (uuid, created_at, name, producer_ids_hash)
      VALUES
      (uuid(), v_created_at, in_name, SHA2(in_producer_ids, 256));
    SET v_static_id = (
      SELECT last_insert_id()
    );

    -- insert a row into the mapping table for each value in the in_producer_ids comma delimited string
    SET v_can_still_find_values_in_delimited_string = true;
    SET v_delimited_string_access_index = 0;
    WHILE (v_can_still_find_values_in_delimited_string) DO
      SET v_delimited_string_access_value = get_from_delimiter_split_string(in_producer_ids, ',', v_delimited_string_access_index); -- get value from string
      SET v_delimited_string_access_index = v_delimited_string_access_index + 1;
      IF (v_delimited_string_access_value = '') THEN
        SET v_can_still_find_values_in_delimited_string = false; -- no value at this index, stop looping
      ELSE
        INSERT INTO movie_to_producer
          (created_at, movie_id, producer_id)
          VALUES
          (v_created_at, v_static_id, v_delimited_string_access_value);
      END IF;
    END WHILE;
  END IF;

  -- insert new version to ensure that latest dynamic data is effective, if dynamic data has changed
  SET v_matching_version_id = ( -- see if latest version already has this data
    SELECT id
    FROM movie_version
    WHERE 1=1
      AND movie_id = v_static_id -- for this entity
      AND effective_at = ( -- and is the version effective at the time of \\"v_effective_at\\"
        SELECT MAX(effective_at)
        FROM movie_version ssv
        WHERE ssv.movie_id = v_static_id
          AND effective_at <= v_effective_at
      )
      AND (language_ids_hash = BINARY SHA2(in_language_ids, 256))
  );
  IF (v_matching_version_id IS NULL) THEN -- if the latest version does not match, insert a new version
    INSERT INTO movie_version
      (movie_id, created_at, effective_at, language_ids_hash)
      VALUES
      (v_static_id, v_created_at, v_effective_at, SHA2(in_language_ids, 256));
    SET v_matching_version_id = (
      SELECT last_insert_id()
    );

    -- insert a row into the mapping table for each value in the in_language_ids comma delimited string
    SET v_can_still_find_values_in_delimited_string = true;
    SET v_delimited_string_access_index = 0;
    WHILE (v_can_still_find_values_in_delimited_string) DO
      SET v_delimited_string_access_value = get_from_delimiter_split_string(in_language_ids, ',', v_delimited_string_access_index); -- get value from string
      SET v_delimited_string_access_index = v_delimited_string_access_index + 1;
      IF (v_delimited_string_access_value = '') THEN
        SET v_can_still_find_values_in_delimited_string = false; -- no value at this index, stop looping
      ELSE
        INSERT INTO movie_version_to_language
          (created_at, movie_version_id, language_id)
          VALUES
          (v_created_at, v_matching_version_id, v_delimited_string_access_value);
      END IF;
    END WHILE;
  END IF;

  -- update the current version pointer table, if it is not already up to date
  SET v_current_version_id_recorded_in_pointer_table = ( -- get the version recorded as current for the entity, if any
    SELECT movie_version_id
    FROM movie_cvp
    WHERE 1=1
      AND movie_id = v_static_id -- for this entity
  );
  IF (v_current_version_id_recorded_in_pointer_table IS null) THEN -- if its null, then just insert it, since it isn't already defined
    INSERT INTO movie_cvp
      (updated_at, movie_id, movie_version_id)
      VALUES
      (v_created_at, v_static_id, v_matching_version_id);
    SET v_current_version_id_recorded_in_pointer_table = v_matching_version_id; -- and record that the current version recorded is now the real current version
  END IF;
  IF (v_current_version_id_recorded_in_pointer_table <> v_matching_version_id) THEN -- if they are not exactly equal, try to update the current version recorded in the pointer table
    SET v_effective_at_of_current_version_recorded_in_pointer_table = ( -- grab the effective_at value of the recorded current version
      SELECT effective_at
      FROM movie_version
      WHERE id = v_current_version_id_recorded_in_pointer_table
    );
    IF (v_effective_at_of_current_version_recorded_in_pointer_table < v_effective_at) THEN -- update cached current version only if the version we just inserted is \\"newer\\" than the currently cached version
      UPDATE movie_cvp
      SET
        movie_version_id = v_matching_version_id,
        updated_at = v_created_at
      WHERE
      movie_id = v_static_id;
    END IF;
  END IF;

  -- return the static entity id
  return v_static_id;
END"
`;

exports[`generateEntityUpsert fully versioned entity unique on uuid should produce the same syntax as the SHOW CREATE FUNCTION query 1`] = `
"CREATE FUNCTION \`upsert_webstore\`(
  in_uuid char(36),
  in_name varchar(255),
  in_phone_number varchar(11),
  in_email varchar(255),
  in_logo_url varchar(255)
) RETURNS bigint(20)
BEGIN
  -- declarations
  DECLARE v_static_id BIGINT;
  DECLARE v_created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6); -- define a common created_at timestamp to use
  DECLARE v_matching_version_id BIGINT;
  DECLARE v_effective_at DATETIME(6) DEFAULT v_created_at; -- define the effective_at to equal created_at by default (i.e., effective _now_)
  DECLARE v_current_version_id_recorded_in_pointer_table BIGINT;
  DECLARE v_effective_at_of_current_version_recorded_in_pointer_table DATETIME(6);

  -- find or create the static entity
  SET v_static_id = (
    SELECT id
    FROM webstore
    WHERE 1=1
      AND (uuid = BINARY in_uuid)
  );
  IF (v_static_id IS NULL) THEN -- if entity could not be found originally, create the static entity
    INSERT INTO webstore
      (uuid, created_at)
      VALUES
      (in_uuid, v_created_at);
    SET v_static_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- insert new version to ensure that latest dynamic data is effective, if dynamic data has changed
  SET v_matching_version_id = ( -- see if latest version already has this data
    SELECT id
    FROM webstore_version
    WHERE 1=1
      AND webstore_id = v_static_id -- for this entity
      AND effective_at = ( -- and is the version effective at the time of \\"v_effective_at\\"
        SELECT MAX(effective_at)
        FROM webstore_version ssv
        WHERE ssv.webstore_id = v_static_id
          AND effective_at <= v_effective_at
      )
      AND (name = BINARY in_name)
      AND (phone_number = BINARY in_phone_number)
      AND (email = BINARY in_email)
      AND (logo_url = BINARY in_logo_url)
  );
  IF (v_matching_version_id IS NULL) THEN -- if the latest version does not match, insert a new version
    INSERT INTO webstore_version
      (webstore_id, created_at, effective_at, name, phone_number, email, logo_url)
      VALUES
      (v_static_id, v_created_at, v_effective_at, in_name, in_phone_number, in_email, in_logo_url);
    SET v_matching_version_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- update the current version pointer table, if it is not already up to date
  SET v_current_version_id_recorded_in_pointer_table = ( -- get the version recorded as current for the entity, if any
    SELECT webstore_version_id
    FROM webstore_cvp
    WHERE 1=1
      AND webstore_id = v_static_id -- for this entity
  );
  IF (v_current_version_id_recorded_in_pointer_table IS null) THEN -- if its null, then just insert it, since it isn't already defined
    INSERT INTO webstore_cvp
      (updated_at, webstore_id, webstore_version_id)
      VALUES
      (v_created_at, v_static_id, v_matching_version_id);
    SET v_current_version_id_recorded_in_pointer_table = v_matching_version_id; -- and record that the current version recorded is now the real current version
  END IF;
  IF (v_current_version_id_recorded_in_pointer_table <> v_matching_version_id) THEN -- if they are not exactly equal, try to update the current version recorded in the pointer table
    SET v_effective_at_of_current_version_recorded_in_pointer_table = ( -- grab the effective_at value of the recorded current version
      SELECT effective_at
      FROM webstore_version
      WHERE id = v_current_version_id_recorded_in_pointer_table
    );
    IF (v_effective_at_of_current_version_recorded_in_pointer_table < v_effective_at) THEN -- update cached current version only if the version we just inserted is \\"newer\\" than the currently cached version
      UPDATE webstore_cvp
      SET
        webstore_version_id = v_matching_version_id,
        updated_at = v_created_at
      WHERE
      webstore_id = v_static_id;
    END IF;
  END IF;

  -- return the static entity id
  return v_static_id;
END"
`;

exports[`generateEntityUpsert static entity should produce the same syntax as the SHOW CREATE FUNCTION query 1`] = `
"CREATE FUNCTION \`upsert_address_2\`(
  in_street varchar(255),
  in_suite varchar(255),
  in_city varchar(255),
  in_country enum('US','CA','MX'),
  in_weekday_found varchar(15)
) RETURNS bigint(20)
BEGIN
  -- declarations
  DECLARE v_static_id BIGINT;
  DECLARE v_created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6); -- define a common created_at timestamp to use

  -- find or create the static entity
  SET v_static_id = (
    SELECT id
    FROM address_2
    WHERE 1=1
      AND (street = BINARY in_street)
      AND (suite = BINARY in_suite OR (suite IS null AND in_suite IS null))
      AND (city = BINARY in_city)
      AND (country = BINARY in_country)
  );
  IF (v_static_id IS NULL) THEN -- if entity could not be found originally, create the static entity
    INSERT INTO address_2
      (uuid, created_at, street, suite, city, country, weekday_found)
      VALUES
      (uuid(), v_created_at, in_street, in_suite, in_city, in_country, in_weekday_found);
    SET v_static_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- return the static entity id
  return v_static_id;
END"
`;

exports[`generateEntityUpsert static entity unique on uuid should produce the same syntax as the SHOW CREATE FUNCTION query 1`] = `
"CREATE FUNCTION \`upsert_plant_order\`(
  in_uuid char(36),
  in_customer_id bigint(20),
  in_plant_name varchar(255),
  in_quantity int(11)
) RETURNS bigint(20)
BEGIN
  -- declarations
  DECLARE v_static_id BIGINT;
  DECLARE v_created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6); -- define a common created_at timestamp to use

  -- find or create the static entity
  SET v_static_id = (
    SELECT id
    FROM plant_order
    WHERE 1=1
      AND (uuid = BINARY in_uuid)
  );
  IF (v_static_id IS NULL) THEN -- if entity could not be found originally, create the static entity
    INSERT INTO plant_order
      (uuid, created_at, customer_id, plant_name, quantity)
      VALUES
      (in_uuid, v_created_at, in_customer_id, in_plant_name, in_quantity);
    SET v_static_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- return the static entity id
  return v_static_id;
END"
`;

exports[`generateEntityUpsert versioned entity should produce the same syntax as the SHOW CREATE FUNCTION query 1`] = `
"CREATE FUNCTION \`upsert_alternative_user\`(
  in_cognito_uuid char(36),
  in_name varchar(255),
  in_bio text
) RETURNS bigint(20)
BEGIN
  -- declarations
  DECLARE v_static_id BIGINT;
  DECLARE v_created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6); -- define a common created_at timestamp to use
  DECLARE v_matching_version_id BIGINT;
  DECLARE v_effective_at DATETIME(6) DEFAULT v_created_at; -- define the effective_at to equal created_at by default (i.e., effective _now_)
  DECLARE v_current_version_id_recorded_in_pointer_table BIGINT;
  DECLARE v_effective_at_of_current_version_recorded_in_pointer_table DATETIME(6);

  -- find or create the static entity
  SET v_static_id = (
    SELECT id
    FROM alternative_user
    WHERE 1=1
      AND (cognito_uuid = BINARY in_cognito_uuid)
  );
  IF (v_static_id IS NULL) THEN -- if entity could not be found originally, create the static entity
    INSERT INTO alternative_user
      (uuid, created_at, cognito_uuid)
      VALUES
      (uuid(), v_created_at, in_cognito_uuid);
    SET v_static_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- insert new version to ensure that latest dynamic data is effective, if dynamic data has changed
  SET v_matching_version_id = ( -- see if latest version already has this data
    SELECT id
    FROM alternative_user_version
    WHERE 1=1
      AND alternative_user_id = v_static_id -- for this entity
      AND effective_at = ( -- and is the version effective at the time of \\"v_effective_at\\"
        SELECT MAX(effective_at)
        FROM alternative_user_version ssv
        WHERE ssv.alternative_user_id = v_static_id
          AND effective_at <= v_effective_at
      )
      AND (name = BINARY in_name)
      AND (bio = BINARY in_bio OR (bio IS null AND in_bio IS null))
  );
  IF (v_matching_version_id IS NULL) THEN -- if the latest version does not match, insert a new version
    INSERT INTO alternative_user_version
      (alternative_user_id, created_at, effective_at, name, bio)
      VALUES
      (v_static_id, v_created_at, v_effective_at, in_name, in_bio);
    SET v_matching_version_id = (
      SELECT last_insert_id()
    );
  END IF;

  -- update the current version pointer table, if it is not already up to date
  SET v_current_version_id_recorded_in_pointer_table = ( -- get the version recorded as current for the entity, if any
    SELECT alternative_user_version_id
    FROM alternative_user_cvp
    WHERE 1=1
      AND alternative_user_id = v_static_id -- for this entity
  );
  IF (v_current_version_id_recorded_in_pointer_table IS null) THEN -- if its null, then just insert it, since it isn't already defined
    INSERT INTO alternative_user_cvp
      (updated_at, alternative_user_id, alternative_user_version_id)
      VALUES
      (v_created_at, v_static_id, v_matching_version_id);
    SET v_current_version_id_recorded_in_pointer_table = v_matching_version_id; -- and record that the current version recorded is now the real current version
  END IF;
  IF (v_current_version_id_recorded_in_pointer_table <> v_matching_version_id) THEN -- if they are not exactly equal, try to update the current version recorded in the pointer table
    SET v_effective_at_of_current_version_recorded_in_pointer_table = ( -- grab the effective_at value of the recorded current version
      SELECT effective_at
      FROM alternative_user_version
      WHERE id = v_current_version_id_recorded_in_pointer_table
    );
    IF (v_effective_at_of_current_version_recorded_in_pointer_table < v_effective_at) THEN -- update cached current version only if the version we just inserted is \\"newer\\" than the currently cached version
      UPDATE alternative_user_cvp
      SET
        alternative_user_version_id = v_matching_version_id,
        updated_at = v_created_at
      WHERE
      alternative_user_id = v_static_id;
    END IF;
  END IF;

  -- return the static entity id
  return v_static_id;
END"
`;
